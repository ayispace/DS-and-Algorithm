选择排序十分简单粗暴，既然我们需要排序，那就一个一个的找到最小值，将其按照升序或降序排列就行了。

所谓的选择的意思就是，每次选一个作为有序序列的一部分。





例如：3 6 1 9 10 2 



+ **先从 3 开始便利，依次向后对比，如果出现比 3 小的数就定位到这个数字，直到遍历完数组，将最小的数和第一个数交换位置。 这时的序列为：1 6 3 9 10 2**

+ **接下来从 6 的位置开始遍历，找到最小的 2 ，与6交换 得到：1 2 3 9 10 6**

+ **接下来从 3 的位置开始遍历，找到最小的 3 ，与3交换 得到：1 2 3 9 10 6**

+ **接下来从 9 的位置开始遍历，找到最小的 6 ，与9交换 得到：1 2 3 6 10 9**

+ **接下来从 10 的位置开始遍历，找到最小的 9 ，与10交换 得到：1 2 3 6 9 10**

+ **结束**



代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
int a[1010];
int n;

int main() {
    // 输入
    cin >> n;
    for (int i = 1; i <= n; ++i) cin >> a[i];
    
    // 选择排序过程
    for (int i = 1; i < n; ++i) {  // 枚举应该归位的第i个元素，这里因为前n-1位归为以后，
                                   // 第n位也会归位，所以我们只枚举到n-1。
        int min_pos = i;           // 将最小值位置设置为当前范围i~n的首位
        for (int j = i + 1; j <= n; ++j) { // 将第i个元素和剩下的元素相比较
            if (a[j] < a[min_pos]) {       // 如果当前元素小于之前维护的最小值
                min_pos = j;               // 更改最小值出现的位置
            }
        }
        swap(a[i], a[min_pos]);            // 将最小值与第i个位置交换
    }
    
    // 输出
    for (int i = 1; i <= n; ++i) 
        cout << a[i] << ' ';
    return 0;
}
```


